<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[总结（一）：javascript闭包（作用域链、垃圾回收机制）]]></title>
      <url>https://teresaruan.github.io/2016/10/12/js1/</url>
      <content type="html"><![CDATA[<p>&#8195;&#8195;最近参加了一个面试，被问到闭包的问题，发现自己半知半解的回答的不太好，回来查了下资料，写篇总结帮助自己梳理一下。</p>
<p>###什么是闭包？<br>&#8195;&#8195;权威指南上的解释是：函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性被称为“闭包”。</p>
<p>&#8195;&#8195;所以从定义的角度来看，所有的js函数都是闭包。</p>
<p>###作用域链<br>&#8195;&#8195;每一个函数在被定义的时候都会保存一个作用域链（一个对象列表或链表），其有一个[scope]的内部属性（这个属性实际上是不存在的，是无法被访问到的），该属性保存着父作用域的作用域链如:</p>
<pre><code>function c（x，y）{}
</code></pre><p>函数c的[scope]属性只有一个全局对象。此时若c中嵌套一个b函数形如：  </p>
<pre><code>function c(x,y){
 function b(){}
}  
</code></pre><p>&#8195;&#8195;此时函数b的[scope]属性包含两个对象：第一个对象是函数c的活动对象（AO），另一个是全局对象。<br>&#8195;&#8195;当函数被调用时，引擎会自动创建一个执行上下文环境，函数创建一个新对象，保存当前函数的局部变量、参数（即函数的活动对象），并把该对象置于作用域链的顶端。函数返回时，该对象会被移除。  </p>
<pre><code>tips:1.每次外部函数被调用，内部函数的作用链会被重新定义。因为外部函数的作用域
       链改变了。
     2.所有的函数，他们的第一个对象都是其参数和局部变量   
</code></pre><p>&#8195;&#8195;js执行时遇到标识符就会顺着对应的作用域向下查找，若无查找结果则抛出一个引用错误。</p>
<p>当嵌套函数的情况时:</p>
<pre><code>function c(x,y){
var a=1;
function b(){
var a=2;
console.log( a+x+y);
}
return b;
}
c(1,2)();//输出为5
</code></pre><p>###垃圾回收机制（GC）<br>&#8195;&#8195;<strong>垃圾回收机制</strong>：当对象不再被引用，就会被回收，其占用的内存会被释放。</p>
<p>&#8195;&#8195;这个现象在函数中非常常见，在函数执行后其中的局部变量就会被回收。</p>
<p>###闭包与它们之间的关系</p>
<p>&#8195;&#8195;js采用的是词法作用域，函数执行在它的定义域，即函数执行依赖于它定义<br>时的变量作用域。  </p>
<p>&#8195;&#8195;以下主要是讲述嵌套函数的一些情况：</p>
<ol>
<li><p><strong>嵌套函数作为局部变量形式存在。</strong>  它会和它指向的变量绑定对象一样被回收。如：</p>
<p> function a(){<br> var s=0;<br> function c(){<br> s++<br> }<br> c();<br> }<br> var fn=a();<br> console.log(a,a.c);//function a(){} ,undefined</p>
</li>
<li><p><strong>嵌套函数作为返回值返回或存储在某处属性中时。</strong>此时会有一个外部引用指向这个嵌套函数，它就不会被当作垃圾回收，其指向的变量绑定对象也不会被回收。如： </p>
<p> function a(){<br> var s=0;<br> function c(){<br> s++;<br> console.log(s);<br> }<br> return c;<br> }<br> var fn=a();<br> fn();// 1<br> fn();// 2<br> fn=null;//可以释放内存，解除引用，嵌套函数会等待被回收</p>
</li>
</ol>
<p>###闭包的应用</p>
<ol>
<li>私有变量声明</li>
<li>私有变量共同变量的共享</li>
<li>需要变量常驻内存中的情况</li>
</ol>
<p>###闭包的危害</p>
<p>&#8195;&#8195;闭包容易造成“循环引用”（注1），在IE中会导致内存泄漏（注2）的问题。</p>
<p><strong>注1</strong>：循环引用：多个对象之间互相引用<br><strong>注2</strong>：内存泄漏：在某些情况下，浏览器不能回收没有用的对象所占用的内存。<br>在浏览器关闭前，就算是刷新页面造成改情况的那部分内存也不会被释放。</p>
]]></content>
    </entry>
    
  
  
</search>
