<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[总结（二）：js事件代理（委托）]]></title>
      <url>https://teresaruan.github.io/2016/10/13/summarize2/</url>
      <content type="html"><![CDATA[<p>&#8195;&#8195;总结第二发：事件代理（委托）。之前有在很多时候听说这个名词但也就是一听而过，以至于被问到了，只能使听过。必须好好整理下！  </p>
<h3 id="什么是事件代理？"><a href="#什么是事件代理？" class="headerlink" title="什么是事件代理？"></a>什么是事件代理？</h3><p><strong>事件代理</strong>：事件代理就是利用事件冒泡，只制定一个事件处理程序，就可以管理某一类型的所有事件。(出自高级程序设计)  </p>
<p><strong>事件冒泡</strong>：当触发了事件，事件从目标节点开发，层层向上传播事件。</p>
<p>例如有如下的html结构：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">'test'</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">ul</span>&gt;</span>  </div><div class="line">```    </div><div class="line"></div><div class="line">&amp;#8195;&amp;#8195;点击li会触发li的点击事件，然后是ul的点击事件，接着是ul的父节点以此类推。  </div><div class="line">&amp;#8195;&amp;#8195;根据事件冒泡的特性，如上例，我们对li注册事件侦听可以移到在其父节点ul上注册一个事件侦听。</div><div class="line"></div><div class="line">### 使用事件代理的原因  </div><div class="line"></div><div class="line">1. **提高性能**。  </div><div class="line">*还是用上面的html结构来举例子*  </div><div class="line"></div><div class="line">  &amp;#8195;&amp;#8195;当我们要输出每个li节点的内容，不用事件代理，for循环遍历：  </div><div class="line">```javascript  </div><div class="line">  </div><div class="line">	window.onload=function()&#123;  </div><div class="line">	var arrList=document.querySelectorAll('#test li');</div><div class="line">	for(var i=0,j=arrList.length;i<span class="tag">&lt;<span class="name">j;i++)&#123;</span></span></div><div class="line">	<span class="attr">arrList</span>[<span class="attr">i</span>]<span class="attr">.onclick</span>=<span class="string">function()&#123;</span></div><div class="line">	<span class="attr">console.log</span>(<span class="attr">this.innerHTML</span>);</div><div class="line">	  &#125;</div><div class="line">	 &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p> 使用事件代理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">	<span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </div><div class="line">	<span class="keyword">var</span> eleUl=<span class="built_in">document</span>.querySelector(<span class="string">'#test'</span>);</div><div class="line">	eleUl.onClick=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> event=event||<span class="built_in">window</span>.event;</div><div class="line">	<span class="keyword">var</span> target=event.target||event.srcElement;</div><div class="line">	<span class="built_in">console</span>.log(target.innerHTML)</div><div class="line">	  &#125;</div><div class="line">	&#125;</div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line">   </div><div class="line">&amp;#8195;&amp;#8195;在一般的web开发中，js的主要的性能问题就是dom操作，在不用事件委托的时候需要进行多次的dom操作。并且每一个函数都是一个对象，对象会占用内存，减少对象的存在可减少内存占用。</div><div class="line"></div><div class="line">2. **当有新的节点出现的时候也不用重新改写函数**</div><div class="line"></div><div class="line">例如当我把li节点的结构改写为</div><div class="line"></div><div class="line">`<span class="string">``</span>html</div><div class="line"></div><div class="line">	&lt;li&gt;<span class="number">1</span>&lt;div&gt;<span class="number">111</span>&lt;<span class="regexp">/div&gt;&lt;/</span>li&gt;</div></pre></td></tr></table></figure>
<p>&#8195;&#8195;同样的我也想给li内的div添加一个点击事件，让其输出其内的内容，如果没有用事件代理我就需要重新再写一个事件侦听（也许有其他比较好的办法），增加了工作量。但在使用了事件委托之后就没有了这种情况。之前写的方法就可以满足需求。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&#8195;&#8195;所以合理地使用事件代理是很有必要的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[总结（一）：javascript闭包（作用域链、垃圾回收机制）]]></title>
      <url>https://teresaruan.github.io/2016/10/12/js1/</url>
      <content type="html"><![CDATA[<p>&#8195;&#8195;最近参加了一个面试，被问到闭包的问题，发现自己半知半解的回答的不太好，回来查了下资料，写篇总结帮助自己梳理一下。</p>
<h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>&#8195;&#8195;权威指南上的解释是：函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性被称为“闭包”。</p>
<p>&#8195;&#8195;所以从定义的角度来看，所有的js函数都是闭包。</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>&#8195;&#8195;每一个函数在被定义的时候都会保存一个作用域链（一个对象列表或链表），其有一个[scope]的内部属性（这个属性实际上是不存在的，是无法被访问到的），该属性保存着父作用域的作用域链如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function c（x，y）&#123;  </div><div class="line">....  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数c的[scope]属性只有一个全局对象。此时若c中嵌套一个b函数形如：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function c(x,y)&#123;</div><div class="line">   function b()&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&#8195;&#8195;此时函数b的[scope]属性包含两个对象：第一个对象是函数c的活动对象（AO），另一个是全局对象。<br>&#8195;&#8195;当函数被调用时，引擎会自动创建一个执行上下文环境，函数创建一个新对象，保存当前函数的局部变量、参数（即函数的活动对象），并把该对象置于作用域链的顶端。函数返回时，该对象会被移除。  </p>
<pre><code>tips:1.每次外部函数被调用，内部函数的作用链会被重新定义。因为外部函数的作用域
       链改变了。
     2.所有的函数，他们的第一个对象都是其参数和局部变量   
</code></pre><p>&#8195;&#8195;js执行时遇到标识符就会顺着对应的作用域向下查找，若无查找结果则抛出一个引用错误。</p>
<p>当嵌套函数的情况时:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">x,y</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log( a+x+y);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> b;</div><div class="line">&#125;</div><div class="line">   c(<span class="number">1</span>,<span class="number">2</span>)();<span class="comment">//输出为5</span></div></pre></td></tr></table></figure>
<h3 id="垃圾回收机制（GC）"><a href="#垃圾回收机制（GC）" class="headerlink" title="垃圾回收机制（GC）"></a>垃圾回收机制（GC）</h3><p>&#8195;&#8195;<strong>垃圾回收机制</strong>：当对象不再被引用，就会被回收，其占用的内存会被释放。</p>
<p>&#8195;&#8195;这个现象在函数中非常常见，在函数执行后其中的局部变量就会被回收。</p>
<h3 id="闭包与它们之间的关系"><a href="#闭包与它们之间的关系" class="headerlink" title="闭包与它们之间的关系"></a>闭包与它们之间的关系</h3><p>&#8195;&#8195;js采用的是词法作用域，函数执行在它的定义域，即函数执行依赖于它定义<br>时的变量作用域。  </p>
<p>&#8195;&#8195;以下主要是讲述嵌套函数的一些情况：</p>
<ol>
<li><strong>嵌套函数作为局部变量形式存在。</strong>  它会和它指向的变量绑定对象一样被回收。如：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> s=<span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;</div><div class="line">s++</div><div class="line">&#125;</div><div class="line">   c();</div><div class="line">&#125;  </div><div class="line"><span class="keyword">var</span> fn=a();</div><div class="line"><span class="built_in">console</span>.log(a,a.c);<span class="comment">//function a()&#123;&#125; ,undefined</span></div></pre></td></tr></table></figure>
<ol>
<li><strong>嵌套函数作为返回值返回或存储在某处属性中时。</strong>此时会有一个外部引用指向这个嵌套函数，它就不会被当作垃圾回收，其指向的变量绑定对象也不会被回收。如：  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;  </div><div class="line"><span class="keyword">var</span> s=<span class="number">0</span>;  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;  </div><div class="line">s++;  </div><div class="line">   <span class="built_in">console</span>.log(s);</div><div class="line">&#125;  </div><div class="line"><span class="keyword">return</span> c;  </div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fn=a();  </div><div class="line">fn();<span class="comment">// 1     </span></div><div class="line">fn();<span class="comment">// 2  </span></div><div class="line">fn=<span class="literal">null</span>;<span class="comment">//可以释放内存，解除引用，嵌套函数会等待被回收</span></div></pre></td></tr></table></figure>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><ol>
<li>私有变量声明</li>
<li>私有变量共同变量的共享</li>
<li>需要变量常驻内存中的情况</li>
</ol>
<h3 id="闭包的危害"><a href="#闭包的危害" class="headerlink" title="闭包的危害"></a>闭包的危害</h3><p>&#8195;&#8195;闭包容易造成“循环引用”（注1），在IE中会导致内存泄漏（注2）的问题。</p>
<p><strong>注1</strong>：循环引用：多个对象之间互相引用<br><strong>注2</strong>：内存泄漏：在某些情况下，浏览器不能回收没有用的对象所占用的内存。<br>在浏览器关闭前，就算是刷新页面造成改情况的那部分内存也不会被释放。</p>
]]></content>
    </entry>
    
  
  
</search>
