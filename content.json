[{"title":"总结（二）：js事件代理（委托）","date":"2016-10-13T15:30:34.000Z","path":"2016/10/13/summarize2/","text":"&#8195;&#8195;总结第二发：事件代理（委托）。之前有在很多时候听说这个名词但也就是一听而过，以至于被问到了，只能使听过。必须好好整理下！ 什么是事件代理？事件代理：事件代理就是利用事件冒泡，只制定一个事件处理程序，就可以管理某一类型的所有事件。(出自高级程序设计) 事件冒泡：当触发了事件，事件从目标节点开发，层层向上传播事件。 例如有如下的html结构： 12345 &lt;ul id=\"test\"&gt; &lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;/ul&gt; 点击li会触发li的点击事件，然后是ul的点击事件，接着是ul的父节点以此类推。根据事件冒泡的特性，如上例，我们对li注册事件侦听可以移到在其父节点ul上注册一个事件侦听。 使用事件代理的原因 提高性能。还是用上面的html结构来举例子 &#8195;&#8195;当我们要输出每个li节点的内容，不用事件代理，for循环遍历： 12345678window.onload=function()&#123; var arrList=document.querySelectorAll(&apos;#test li&apos;);for(var i=0,j=arrList.length;i&lt;j;i++)&#123; arrList[i].onclick=function()&#123; console.log(this.innerHTML); &#125; &#125; &#125; 使用事件代理： 123456789window.onload=function()&#123; var eleUl=document.querySelector(&apos;#test&apos;);eleUl.onClick=function(event)&#123;var event=event||window.event;//支持 ie6-8，target触发事件的节点var target=event.target||event.srcElement;console.log(target.innerHTML) &#125;&#125; &#8195;&#8195;在一般的web开发中，js的主要的性能问题就是dom操作，在不用事件委托的时候需要进行多次的dom操作。并且每一个函数都是一个对象，对象会占用内存，减少对象的存在可减少内存占用。 当有新的节点出现的时候也不用重新改写函数 例如当我把li节点的结构改写为 1&lt;li&gt;1&lt;div&gt;111&lt;/div&gt;&lt;/li&gt; &#8195;&#8195;同样的我也想给li内的div添加一个点击事件，让其输出其内的内容，如果没有用事件代理我就需要重新再写一个事件侦听（也许有其他比较好的办法），增加了工作量。但在使用了事件委托之后就没有了这种情况。之前写的方法就可以满足需求。 总结&#8195;&#8195;所以合理地使用事件代理是很有必要的。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://teresaruan.github.io/tags/javascript/"}]},{"title":"总结（一）：javascript闭包（作用域链、垃圾回收机制）","date":"2016-10-12T14:29:00.000Z","path":"2016/10/12/js1/","text":"&#8195;&#8195;最近参加了一个面试，被问到闭包的问题，发现自己半知半解的回答的不太好，回来查了下资料，写篇总结帮助自己梳理一下。 什么是闭包？&#8195;&#8195;权威指南上的解释是：函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性被称为“闭包”。 &#8195;&#8195;所以从定义的角度来看，所有的js函数都是闭包。 作用域链&#8195;&#8195;每一个函数在被定义的时候都会保存一个作用域链（一个对象列表或链表），其有一个[scope]的内部属性（这个属性实际上是不存在的，是无法被访问到的），该属性保存着父作用域的作用域链如: 123function c（x，y）&#123; .... &#125; 函数c的[scope]属性只有一个全局对象。此时若c中嵌套一个b函数形如： 123function c(x,y)&#123; function b()&#123;&#125;&#125; &#8195;&#8195;此时函数b的[scope]属性包含两个对象：第一个对象是函数c的活动对象（AO），另一个是全局对象。&#8195;&#8195;当函数被调用时，引擎会自动创建一个执行上下文环境，函数创建一个新对象，保存当前函数的局部变量、参数（即函数的活动对象），并把该对象置于作用域链的顶端。函数返回时，该对象会被移除。 tips:1.每次外部函数被调用，内部函数的作用链会被重新定义。因为外部函数的作用域 链改变了。 2.所有的函数，他们的第一个对象都是其参数和局部变量 &#8195;&#8195;js执行时遇到标识符就会顺着对应的作用域向下查找，若无查找结果则抛出一个引用错误。 当嵌套函数的情况时: 12345678910function c(x,y)&#123;var a=1;function b()&#123;var a=2;console.log( a+x+y);&#125;return b;&#125; c(1,2)();//输出为5 垃圾回收机制（GC）&#8195;&#8195;垃圾回收机制：当对象不再被引用，就会被回收，其占用的内存会被释放。 &#8195;&#8195;这个现象在函数中非常常见，在函数执行后其中的局部变量就会被回收。 闭包与它们之间的关系&#8195;&#8195;js采用的是词法作用域，函数执行在它的定义域，即函数执行依赖于它定义时的变量作用域。 &#8195;&#8195;以下主要是讲述嵌套函数的一些情况： 1.嵌套函数作为局部变量形式存在。 它会和它指向的变量绑定对象一样被回收。如： 12345678910function a()&#123;var s=0;function c()&#123;s++&#125; c();&#125; var fn=a();console.log(a,a.c);//function a()&#123;&#125; ,undefined 2.嵌套函数作为返回值返回或存储在某处属性中时。此时会有一个外部引用指向这个嵌套函数，它就不会被当作垃圾回收，其指向的变量绑定对象也不会被回收。如： 12345678910111213 function a()&#123; var s=0; function c()&#123; s++; console.log(s);&#125; return c; &#125;var fn=a(); fn();// 1 fn();// 2 fn=null;//可以释放内存，解除引用，嵌套函数会等待被回收 闭包的应用 私有变量声明 私有变量共同变量的共享 需要变量常驻内存中的情况 闭包的危害&#8195;&#8195;闭包容易造成“循环引用”（注1），在IE中会导致内存泄漏（注2）的问题。 注1：循环引用：多个对象之间互相引用注2：内存泄漏：在某些情况下，浏览器不能回收没有用的对象所占用的内存。在浏览器关闭前，就算是刷新页面造成改情况的那部分内存也不会被释放。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://teresaruan.github.io/tags/javascript/"}]}]